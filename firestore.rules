/**
 * @file Firestore Security Rules
 * @version 2
 *
 * @description This ruleset defines access control for a CMS, enforcing a combination of public read access for some content types (e.g., Pages, Posts) and owner-only write access for other content (e.g., Media, Custom Themes).
 *
 * Data Structure:
 * The Firestore database is structured with top-level collections for each content type:
 * - /pages/{pageId}: Stores static page data.
 * - /categories/{categoryId}: Stores category data.
 * - /tags/{tagId}: Stores tag data.
 * - /posts/{postId}: Stores blog post and article data.
 * - /media/{mediaId}: Stores media items.
 * - /site_settings/config: Stores global site settings.
 * - /widget_areas/{widgetAreaId}: Stores defined widget areas.
 * - /widget_instances/{widgetInstanceId}: Stores configured widget instances.
 * - /navigation_menus/{menuId}: Stores reusable navigation menus.
 * - /navigation_menu_items/{itemId}: Stores individual navigation menu items.
 * - /custom_themes/{themeId}: Stores user-created custom themes.
 * - /page_layouts/{pageLayoutId}: Stores reusable page layouts.
 * - /block_layouts/{blockLayoutId}: Stores reusable block layouts.
 *
 * Key Security Decisions:
 * - Public Read Access: The `pages`, `categories`, `tags`, and `posts` collections are publicly readable. However, writes are restricted to authorized users who must be the author of the content.
 * - Owner-Only Write Access: The `media` and `custom_themes` collections enforce strict user ownership for writes.
 * - Singleton Document: The `site_settings/config` document is read/write accessible for any signed in user.
 * - No User Listing: Listing all users is not permitted.
 * - Default Security Posture: In cases where ownership is unclear or the data model is incomplete, a restrictive "allow create, update, delete: if false;" rule is applied as a placeholder. This ensures that no data is accidentally exposed and alerts developers to the missing ownership implementation.
 *
 * Denormalization for Authorization:
 * - Author IDs are denormalized directly onto the `Page`, `Post`, `MediaItem`, and `CustomTheme` documents. This enables fast and efficient ownership checks without requiring additional `get()` operations.
 *
 * Structural Segregation:
 * - Publicly readable content (e.g., published posts) and private user data are stored in separate collections to simplify security rules and improve query performance.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @return {bool} True if the user is signed in, false otherwise.
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the authenticated user ID matches the provided user ID.
     * @param {string} userId The user ID to compare against the authenticated user ID.
     * @return {bool} True if the user IDs match, false otherwise.
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the authenticated user is the owner of the existing document.
     *              It also verifies that the document exists.
     * @param {string} userId The user ID to compare against the document's owner ID.
     * @return {bool} True if the user is the owner and the document exists, false otherwise.
     */
    function isExistingOwner(userId) {
      return isOwner(userId) && resource != null;
    }

    /**
     * @description Allows any signed-in user to read any page. Only the author can modify pages.
     * @path /pages/{pageId}
     * @allow (get, list): Any signed-in user can read any page.
     * @allow (create): Any signed-in user can create a page if the authorId matches their UID.
     * @allow (update, delete): Only the author of the page can update or delete it.
     * @deny (create): If the authorId does not match the signed-in user's UID.
     * @deny (update, delete): If the signed-in user is not the author of the page.
     * @principle Enforces document ownership for writes while allowing public reads.
     */
    match /pages/{pageId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows any signed-in user to read any category.
     * @path /categories/{categoryId}
     * @allow (get, list): Any signed-in user can read any category.
     * @allow (write): Only the author can modify categories.
     * @principle Enforces document ownership for writes while allowing public reads.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add author validation once the schema is updated with an ownership field.
      allow update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows any signed-in user to read any tag.
     * @path /tags/{tagId}
     * @allow (get, list): Any signed-in user can read any tag.
     * @allow (write): Only the author can modify tags.
     * @principle Enforces document ownership for writes while allowing public reads.
     */
    match /tags/{tagId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add author validation once the schema is updated with an ownership field.
      allow update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows any signed-in user to read any post. Only the author can modify posts.
     * @path /posts/{postId}
     * @allow (get, list): Any signed-in user can read any post.
     * @allow (create): Any signed-in user can create a post if the authorId matches their UID.
     * @allow (update, delete): Only the author of the post can update or delete it.
     * @deny (create): If the authorId does not match the signed-in user's UID.
     * @deny (update, delete): If the signed-in user is not the author of the post.
     * @principle Enforces document ownership for writes while allowing public reads.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows a user to manage their own media items.
     * @path /media/{mediaId}
     * @allow (create): Only the signed-in user can create media files, authorId must match.
     * @allow (get, list): Any signed-in user can read any media item.
     * @allow (update, delete): Only the owner can update or delete their media items.
     * @deny (create): If the authorId does not match the signed-in user's UID.
     * @deny (update, delete): If the signed-in user is not the owner of the media item.
     * @principle Enforces strict document ownership for all operations.
     */
    match /media/{mediaId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows any signed-in user to read/write site settings.
     * @path /site_settings/config
     * @allow (get): Any signed-in user can read site settings.
     * @allow (write): Any signed-in user can create, update, or delete site settings.
     * @principle Allows any signed-in user to manage site-wide settings.
     */
    match /site_settings/config {
      allow get: if true;
      allow create, update, delete: if isSignedIn();
    }

    /**
     * @description Allows any signed-in user to read/write widget areas.
     * @path /widget_areas/{widgetAreaId}
     */
    match /widget_areas/{widgetAreaId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add author validation once the schema is updated with an ownership field.
      allow update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows any signed-in user to read/write widget instances.
     * @path /widget_instances/{widgetInstanceId}
     */
    match /widget_instances/{widgetInstanceId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add author validation once the schema is updated with an ownership field.
      allow update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows any signed-in user to read/write navigation menus.
     * @path /navigation_menus/{menuId}
     */
    match /navigation_menus/{menuId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add author validation once the schema is updated with an ownership field.
      allow update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows any signed-in user to read/write navigation menu items.
     * @path /navigation_menu_items/{itemId}
     */
    match /navigation_menu_items/{itemId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add author validation once the schema is updated with an ownership field.
      allow update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows a user to manage their own custom themes.
     * @path /custom_themes/{themeId}
     * @allow (create): Only the signed-in user can create custom themes, authorId must match.
     * @allow (get, list): Any signed-in user can read any custom theme.
     * @allow (update, delete): Only the owner can update or delete their custom themes.
     * @deny (create): If the authorId does not match the signed-in user's UID.
     * @deny (update, delete): If the signed-in user is not the owner of the custom theme.
     * @principle Enforces strict document ownership for all operations.
     */
    match /custom_themes/{themeId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Allows any signed-in user to read/write page layouts.
     * @path /page_layouts/{pageLayoutId}
     */
    match /page_layouts/{pageLayoutId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add author validation once the schema is updated with an ownership field.
      allow update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Allows any signed-in user to read/write block layouts.
     * @path /block_layouts/{blockLayoutId}
     */
    match /block_layouts/{blockLayoutId} {
      allow get, list: if true;
      allow create: if isSignedIn(); // TODO: Add author validation once the schema is updated with an ownership field.
      allow update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}