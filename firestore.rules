/**
 * @fileoverview Firestore Security Rules for the CMS.
 *
 * Core Philosophy: This ruleset prioritizes simplicity and security by enforcing owner-based access control for writable collections.
 * Read access is generally public for top-level collections to facilitate content delivery.
 *
 * Data Structure: Data is stored in top-level collections: /pages/{pageId}, /categories/{categoryId}, /tags/{tagId},
 * /posts/{postId}, /media/{mediaId}, /site_settings/config, /widget_areas/{widgetAreaId}, /widget_instances/{widgetInstanceId}, /navigation_menus/{menuId}, /navigation_menu_items/{itemId}.
 * Each collection stores documents representing entities like pages, categories, posts, media items, and site settings.
 *
 * Key Security Decisions:
 * - Public Read Access: The rules allow public read access (get, list) to most top-level collections, assuming the content is intended for general consumption.
 * - Owner-Only Writes: Write operations (create, update, delete) are generally restricted to the owner (author) of the respective document.
 * - Centralized Site Settings: Only authenticated users can modify the site configuration.
 * - No User Listing: Listing users is not permitted.
 *
 * Denormalization for Authorization: The rules assume that documents contain an `authorId` field that matches the authenticated user's UID.
 * This allows for efficient owner-based access control without additional `get()` calls.
 *
 * Structural Segregation: There is no need for private user subcollections.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Manages access control for static pages.
     * @path /pages/{pageId}
     * @allow (get, list): Anyone can read page content.
     * @allow (create, update, delete): Only the author can modify or delete a page.
     * @deny create: if request.auth.uid == null;
     * @deny update: if request.auth.uid == null;
     * @deny delete: if request.auth.uid == null;
     * @principle Public read, owner-only writes with authorId field validation.
     */
    match /pages/{pageId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages access control for categories.
     * @path /categories/{categoryId}
     * @allow (get, list): Anyone can read category information.
     * @allow (create, update, delete): Only the author can modify or delete a category.
     * @deny create: if request.auth.uid == null;
     * @deny update: if request.auth.uid == null;
     * @deny delete: if request.auth.uid == null;
     * @principle Public read, owner-only writes with authorId field validation.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages access control for tags.
     * @path /tags/{tagId}
     * @allow (get, list): Anyone can read tag information.
     * @allow (create, update, delete): Only the author can modify or delete a tag.
     * @deny create: if request.auth.uid == null;
     * @deny update: if request.auth.uid == null;
     * @deny delete: if request.auth.uid == null;
     * @principle Public read, owner-only writes with authorId field validation.
     */
    match /tags/{tagId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages access control for posts.
     * @path /posts/{postId}
     * @allow (get, list): Anyone can read post content.
     * @allow (create, update, delete): Only the author can modify or delete a post.
     * @deny create: if request.auth.uid == null;
     * @deny update: if request.auth.uid == null;
     * @deny delete: if request.auth.uid == null;
     * @principle Public read, owner-only writes with authorId field validation.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages access control for media items.
     * @path /media/{mediaId}
     * @allow (get, list): Anyone can read media item.
     * @allow (create, update, delete): Only the author can modify or delete a media item.
     * @deny create: if request.auth.uid == null;
     * @deny update: if request.auth.uid == null;
     * @deny delete: if request.auth.uid == null;
     * @principle Public read, owner-only writes with authorId field validation.
     */
    match /media/{mediaId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages access control for site settings.
     * @path /site_settings/config
     * @allow get: Anyone can read site settings.
     * @allow update: Only authenticated users can modify site settings.
     * @deny create: if false;
     * @deny delete: if false;
     * @principle Authenticated users can modify site settings.
     */
    match /site_settings/config {
      allow get: if true;
      allow update: if isSignedIn();
      allow create: if false;
      allow delete: if false;
    }

    /**
     * @description Manages access control for widget areas.
     * @path /widget_areas/{widgetAreaId}
     * @allow get, list: if true;
     * @allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
     * @allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
     * @deny create: if request.auth.uid == null;
     * @deny update: if request.auth.uid == null;
     * @deny delete: if request.auth.uid == null;
     * @principle Public read, owner-only writes with authorId field validation.
     */
    match /widget_areas/{widgetAreaId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages access control for widget instances.
     * @path /widget_instances/{widgetInstanceId}
     * @allow get, list: if true;
     * @allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
     * @allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
     * @deny create: if request.auth.uid == null;
     * @deny update: if request.auth.uid == null;
     * @deny delete: if request.auth.uid == null;
     * @principle Public read, owner-only writes with authorId field validation.
     */
    match /widget_instances/{widgetInstanceId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

     /**
      * @description Manages access control for navigation menus.
      * @path /navigation_menus/{menuId}
      * @allow get, list: if true;
      * @allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      * @allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
      * @deny create: if request.auth.uid == null;
      * @deny update: if request.auth.uid == null;
      * @deny delete: if request.auth.uid == null;
      * @principle Public read, owner-only writes with authorId field validation.
      */
    match /navigation_menus/{menuId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Manages access control for navigation menu items.
     * @path /navigation_menu_items/{itemId}
     * @allow get, list: if true;
     * @allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
     * @allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
     * @deny create: if request.auth.uid == null;
     * @deny update: if request.auth.uid == null;
     * @deny delete: if request.auth.uid == null;
     * @principle Public read, owner-only writes with authorId field validation.
     */
    match /navigation_menu_items/{itemId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isSignedIn() && isExistingOwner(resource.data.authorId);
    }
  }

  // Helper function to determine if the user is signed in
  function isSignedIn() {
    return request.auth != null;
  }

  // Helper function to determine if the user is the owner of the document
  function isOwner(authorId) {
    return request.auth.uid == authorId;
  }

  // Helper function to determine if the user is the owner of the document and the document exists
  function isExistingOwner(authorId) {
    return isOwner(authorId) && resource != null;
  }
}