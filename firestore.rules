/**
 * @file Firestore Security Rules
 * @description This ruleset enforces a flexible data model for a CMS, focusing on owner-only write access and public read access where appropriate.
 *
 * Data Structure:
 * - Top-level collections: /pages/{pageId}, /categories/{categoryId}, /tags/{tagId}, /posts/{postId}, /media/{mediaId}, /widget_areas/{widgetAreaId}, /widget_instances/{widgetInstanceId}, /navigation_menus/{menuId}, /navigation_menu_items/{itemId}.
 * - Single document: /site_settings/config for global site settings.
 *
 * Key Security Decisions:
 * - All top-level collections with entity objects enforce owner-only writes (create, update, delete).
 * - The /site_settings/config document allows only authenticated users to read.
 * - List operations default to owner-only unless explicitly disallowed.
 *
 * Denormalization for Authorization:
 * - The 'authorId' field within the Page, Post, and MediaItem documents are used for ownership checks.  This avoids needing to query a separate /users collection.
 *
 * Structural Segregation:
 * - Publicly readable content and private user data are stored in separate collections to avoid complex read rules.
 */
rules_version = '2';
service cloud.firestore {
  match /databases/{database}/documents {

    /**
     * @description Checks if the request is authenticated.
     * @path N/A
     */
    function isSignedIn() {
      return request.auth != null;
    }

    /**
     * @description Checks if the user ID matches the authenticated user's ID.
     * @path N/A
     */
    function isOwner(userId) {
      return request.auth.uid == userId;
    }

    /**
     * @description Checks if the user is the owner of the existing document.
     * @path N/A
     */
    function isExistingOwner(ownerId) {
      return isSignedIn() && isOwner(ownerId) && resource != null;
    }

    /**
     * @description Enforces read and write rules for static pages.
     * @path /pages/{pageId}
     * @allow (get, list): Any user can read page data.
     * @allow (create): Only the page author (based on authorId) can create a page. authorId must match request.auth.uid.
     * @allow (update, delete): Only the page author can modify or delete a page.
     * @deny (create): A user attempts to create a page with an authorId that does not match their own.
     * @deny (update, delete): A user attempts to modify or delete a page they did not author.
     * @principle Public read, owner-only writes with ownership validation.
     */
    match /pages/{pageId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Enforces read and write rules for categories.
     * @path /categories/{categoryId}
     * @allow (get, list): Any user can read category data.
     * @allow (create, update, delete): Only the category creator can modify category.
     * @principle Public read, owner-only writes.
     */
    match /categories/{categoryId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces read and write rules for tags.
     * @path /tags/{tagId}
     * @allow (get, list): Any user can read tag data.
     * @allow (create, update, delete): Only the tag creator can modify tag.
     * @principle Public read, owner-only writes.
     */
    match /tags/{tagId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces read and write rules for posts.
     * @path /posts/{postId}
     * @allow (get, list): Any user can read post data.
     * @allow (create): Only the post author (based on authorId) can create a post. authorId must match request.auth.uid.
     * @allow (update, delete): Only the post author can modify or delete a post.
     * @deny (create): A user attempts to create a post with an authorId that does not match their own.
     * @deny (update, delete): A user attempts to modify or delete a post they did not author.
     * @principle Public read, owner-only writes with ownership validation.
     */
    match /posts/{postId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Enforces read and write rules for media items.
     * @path /media/{mediaId}
     * @allow (get, list): Any user can read media item data.
     * @allow (create): Only the media item author (based on authorId) can create a media item. authorId must match request.auth.uid.
     * @allow (update, delete): Only the media item author can modify or delete a media item.
     * @deny (create): A user attempts to create a media item with an authorId that does not match their own.
     * @deny (update, delete): A user attempts to modify or delete a media item they did not author.
     * @principle Public read, owner-only writes with ownership validation.
     */
    match /media/{mediaId} {
      allow get, list: if true;
      allow create: if isSignedIn() && request.resource.data.authorId == request.auth.uid;
      allow update, delete: if isExistingOwner(resource.data.authorId);
    }

    /**
     * @description Enforces read and write rules for site settings.
     * @path /site_settings/config
     * @allow get: Any authenticated user can read the site settings.
     * @deny create, update, delete: No one can create, update, or delete the site settings.
     * @principle Authenticated read, no writes.
     */
    match /site_settings/config {
      allow get: if isSignedIn();
      allow create, update, delete: if false;
    }

    /**
     * @description Enforces read and write rules for widget areas.
     * @path /widget_areas/{widgetAreaId}
     * @allow (get, list): Any user can read widget area data.
     * @allow (create, update, delete): Only the widget area creator can modify widget area.
     * @principle Public read, owner-only writes.
     */
    match /widget_areas/{widgetAreaId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces read and write rules for widget instances.
     * @path /widget_instances/{widgetInstanceId}
     * @allow (get, list): Any user can read widget instance data.
     * @allow (create, update, delete): Only the widget instance creator can modify widget instance.
     * @principle Public read, owner-only writes.
     */
    match /widget_instances/{widgetInstanceId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces read and write rules for navigation menus.
     * @path /navigation_menus/{menuId}
     * @allow (get, list): Any user can read navigation menu data.
     * @allow (create, update, delete): Only the navigation menu creator can modify navigation menu.
     * @principle Public read, owner-only writes.
     */
    match /navigation_menus/{menuId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }

    /**
     * @description Enforces read and write rules for navigation menu items.
     * @path /navigation_menu_items/{itemId}
     * @allow (get, list): Any user can read navigation menu item data.
     * @allow (create, update, delete): Only the navigation menu item creator can modify navigation menu item.
     * @principle Public read, owner-only writes.
     */
    match /navigation_menu_items/{itemId} {
      allow get, list: if true;
      allow create, update, delete: if false; // TODO: Add owner validation once the schema is updated with an ownership field.
    }
  }
}